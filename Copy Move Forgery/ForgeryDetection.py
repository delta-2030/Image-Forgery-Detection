import numpy as np  # Importing all necessary libraries
import cv2
from sklearn.cluster import DBSCAN

class Detect(object):
    def __init__(self, image):
        self.image = image

    def siftDetector(self): # Applying Scale Invariant Feature Transform
        sift = cv2.SIFT_create()
        gray = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        self.key_points, self.descriptors = sift.detectAndCompute(gray, None)
        return self.key_points, self.descriptors

    def showSiftFeatures(self): # Highlighting the keypoints generated by SIFT algorithm
        sift_image = cv2.drawKeypoints(self.image, self.key_points, self.image.copy())
        return sift_image

    # Below are two methods of highlighting the forged regions.Please only one definition of the function at a time

    # 1st Method joins the forged areas with lines on the origianl image.Below is the code for the same
    def locateForgery(self, eps, min_sample):
        # eps - Max distance between two samples for them to be considered part of same cluster
        # min_sample - Min number of points required to form a cluster
        clusters = DBSCAN(eps=eps, min_samples=min_sample).fit(self.descriptors) # Applying DBSCAN on the keypoints generated by SIFT
        size = np.unique(clusters.labels_).shape[0] - 1 # Subtracting 1 because label (-1) is for outliers or noise
        forgery = self.image.copy()

        if (size == 0) and (np.unique(clusters.labels_)[0] == -1):
            # If no clusters are found and only outliers are present, means no forgery
            print('No Forgery Found!!!')
            return None

        if size == 0: # Handling edge case of a single cluster
            size = 1

        cluster_list = [[] for _ in range(size)]
        for idx in range(len(self.key_points)):
            if clusters.labels_[idx] != -1: # Ignore outliers
                cluster_list[clusters.labels_[idx]].append(
                    (int(self.key_points[idx].pt[0]), int(self.key_points[idx].pt[1]))
                ) # Each valid keypoint is addedd to the cluster list

        for points in cluster_list:
            if len(points) > 1:# Processes cluster that have more than one point
                for idx1 in range(1, len(points)):
                    cv2.line(forgery, points[0], points[idx1], (255, 0, 0), 5) # Connects the first point of the cluster with all other points of the same cluster

        return forgery
    
    # 2nd method generates a mask in which the forged areas are highlighted.Uncomment the following code and comment the above definition of locateforgery if you want to generate mask

    # def locateForgery(self, eps, min_sample):
    #     clusters = DBSCAN(eps=eps, min_samples=min_sample).fit(self.descriptors)
    #     size = np.unique(clusters.labels_).shape[0] - 1 
    #     if (size == 0) and (np.unique(clusters.labels_)[0] == -1):
    #         print('No Forgery Found!!!')
    #         return None
    #     mask = np.zeros(self.image.shape[:2], dtype=np.uint8)
    #     cluster_list = [[] for _ in range(size)]
    #     for idx in range(len(self.key_points)):
    #         if clusters.labels_[idx] != -1:
    #             cluster_list[clusters.labels_[idx]].append(
    #                 (int(self.key_points[idx].pt[0]), int(self.key_points[idx].pt[1]))
    #             )
    #     for points in cluster_list:
    #         if len(points) > 1:
    #             for x, y in points:
    #                 cv2.circle(mask, (x, y), radius=1, color=255, thickness=-1)
    #     kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
    #     kernel_erode = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))

    #     mask = cv2.dilate(mask, kernel_dilate, iterations=2) 
    #     mask = cv2.erode(mask, kernel_erode, iterations=1) 
    #     contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    #     refined_mask = np.zeros_like(mask)
    #     for contour in contours:
    #         if cv2.contourArea(contour) > 50:
    #             cv2.drawContours(refined_mask, [contour], -1, 255, thickness=cv2.FILLED)

    #     return refined_mask
